"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time
from random import sample, randrange


# Декоратор для расчёта времени работы функции


def timer(function):
    def wrapped(*args):
        start_time = time.perf_counter()
        res = function(*args)
        print(f'Функция "{function.__name__}" отработала за - {time.perf_counter() - start_time}')
        return res

    return wrapped


# A-1. Функция для заполнения списка n элементами
@timer
def fill_lst(n):  # O(n)
    lst = sample(range(1, 10000), n)  # O(n)
    return lst  # O(1)


# A-2. Функция для заполнения словаря n элементами
@timer
def fill_dict(n):  # O(n)
    dct = {}  # O(1)
    for k in range(n):  # O(n)
        k = randrange(1, 10000)  # O(1)
        v = 5 * k  # O(1)
        dct[k] = v  # O(1)
    return dct  # O(1)


"""
    Сложность функций по заполнению словаря и списка  одинакова и равна O(n).
Замер времени при создании списка из 5 значений показал, что словарь при таком кол-ве операций 
заполняется быстрее. 
А если задать больше элементов для списка и словаря, здесь уже наглядно, что словарь заполняется дольше 
(хотя и не сильно дольше). Словарь дольше заполняется в связи с тем, что для ключей вычисляется хеш.
"""

print(fill_dict(5))
print(fill_lst(5))
print(fill_dict(77))
print(fill_lst(77))


# В-1. Функция для получения элемента списка
@timer
def get_lst(lst, n):  # O(1)
    el = lst[n]  # O(1)
    return el  # O(1)


# В-2. Функция для получения элемента словаря
@timer
def get_dct(dct, k):  # O(1)
    el = dct.get(k)  # O(1)
    return el  # O(1)


"""
    Сложность функций по получению элемента списка и получению элемента 
словаря  одинакова и равна O(n).
Далее интересно: 
В моих тестах замеры осложнялись тем, что каждый раз генерируется новый список и словарь. 
И, чтобы реализовать замер времени получения элемента из словаря, запускала много раз свой код: 
т.к. в моей функции получения элемента по ключу сделано через dict.get(k), 
в большинстве случаев функции для словаря приходилось возвращать none, поэтому время получалось больше,
чем для списка. Но! Как только я сделала замеры для уже определённого сгенерированного списка, 
увидела ощутимую разницу: получения элемента в словаре по ключу происходит сильно быстрее, т.к.
в словаре хеш ключа уже вычислен.
Благодаря сложным измерениям по времени лишний раз убедилась, что время не идеальный инструмент измерения 
скорости работы алгоритма, т.к. даёт сильно субъективные показатели для разного кол-ва элементов. 
"""

samp_dict = fill_dict(7)
samp_list = fill_lst(7)

s_dict = {5200: 26000, 2514: 12570, 9470: 47350, 3553: 17765, 1359: 6795, 3360: 16800, 4962: 24810}
s_list = [1112, 9211, 299, 2540, 6030, 1280, 3942]
print(samp_dict)
print(samp_list)
print(get_dct(samp_dict, 47))
print(get_lst(samp_list, 4))

print(get_dct(s_dict, 4962))
print(get_lst(s_list, 4))


# С-1. Функция для удаления элемента списка
@timer
def del_lst(lst, n):  # O(n)
    el = lst.pop(n)  # O(n)
    return el  # O(1)


# С-2. Функция для удаления элемента словаря
@timer
def del_dct(dct, k):  # O(1)
    el = dct.pop(k, None)  # O(1)
    return el  # O(1)


"""
   Удаление элемента из словаря быстрее. При удалении элемента из списка пересчитываются индексы оставшихся
элементов. Но опять на небольшом сгенерированном списке могут получится замеры, 
когда время удаления элемента из списка меньше. 
"""

print(del_dct(samp_dict, 47))
print(del_lst(samp_list, 4))

print(del_dct(s_dict, 4962))
print(del_lst(s_list, 4))
